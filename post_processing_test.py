import logging
import numpy as np
import cv2
from utils.post_processing import filter_depth, approx_bounding_box, perform_grabcut, distance_measure

_logger = logging.getLogger(__name__)

CAMERA_ORI = "horizontal"
SHOE_FACTOR = "shoe"
MAX_SAVE_FILES = 5

logging.basicConfig(level=logging.INFO)
_logger.info(f"Current dataset: {CAMERA_ORI} capture | {SHOE_FACTOR}")

for i in np.arange(5):
    # depth image default scale is one millimeter
    depth_image = np.load(f"data/{CAMERA_ORI}/{SHOE_FACTOR}/depth_{i}.npy")
    color_image = np.load(f"data/{CAMERA_ORI}/{SHOE_FACTOR}/color_{i}.npy")

    if CAMERA_ORI == "vertical":
        depth_image = cv2.rotate(depth_image, cv2.ROTATE_90_COUNTERCLOCKWISE)
        color_image = cv2.rotate(color_image, cv2.ROTATE_90_COUNTERCLOCKWISE)

    # cv2.imshow('Original', color_image)
    # cv2.waitKey(0)

    # generate preliminary mask from depth to approx. bounding box
    depth_mask = filter_depth(depth_image, CAMERA_ORI, SHOE_FACTOR, 200, 500)

    # find the approx. bounding box
    (x, y, w, h) = approx_bounding_box(depth_mask, 50, CAMERA_ORI)

    # visualize_img(color_image, depth_image, depth_mask)
    # visualize_img(color_image, depth_image, depth_mask)

    # -------------------------------------------------------------------------
    # GrabCut algorithm
    bounding_box = (x, y, w, h)
    grabcut_mask = perform_grabcut(color_image, bounding_box)

    # apply a bitwise AND to the image using our mask generated by
    # GrabCut to generate our final output image
    color_img = color_image.copy()
    depth_img = depth_image.copy()

    # empty mask declaration
    depth_mask = np.zeros(depth_image.shape, dtype=np.uint8)
    depth_temp = cv2.bitwise_and(depth_img, depth_img, mask=grabcut_mask)

    depth_mask[np.where(depth_temp > 0)] = 255
    depth_mask[np.where(depth_temp > 500)] = 0

    depth_temp = cv2.bitwise_and(depth_img, depth_img, mask=depth_mask)

    # cv2.imshow("Input", color_img)
    # cv2.imshow("GrabCut Mask", outputMask)
    output = cv2.bitwise_and(color_img, color_img, mask=depth_mask)

    # measure the minimum distance
    distance_measure(depth_temp)

    cv2.imshow("GrabCut Output", output)
    cv2.waitKey(0)

    # -------------------------------------------------------------------------

    # # Edge detection
    # img_gray = cv2.cvtColor(color_image, cv2.COLOR_BGR2GRAY)
    # img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)

    # # Sobel Edge Detection
    # sobelxy = cv2.Sobel(src=img_blur, ddepth=cv2.CV_64F, dx=1, dy=1, ksize=5)
    # cv2.imshow('Sobel X Y using Sobel() function', sobelxy)
    # cv2.waitKey(0)

    # # Canny Edge Detection
    # edges = cv2.Canny(image=img_blur, threshold1=100, threshold2=200)
    # cv2.imshow('Canny Edge Detection', edges)
    # cv2.waitKey(0)
